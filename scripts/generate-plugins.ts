/* eslint-disable no-await-in-loop */
import {mkdir, readdir, pathExists, readFile, writeFile} from 'fs-extra';
import {createProgressBar, createHeader} from '@kalimahapps/cli-progress';

import path from 'node:path';
import {parse} from 'yaml';
type NavigationData = {
	title: string;
	description?: string;
};

type PluginFrontmatter = {
	'name': string;
	'category': string;
	'repo': string;
	'author': string;
	'author-url'?: string;
	'demo': string;
	'compatible-v0': boolean;
	'compatible-v1': boolean;
	'compatible-v2': boolean;
};

type PluginData = {
	title: string;
	repo: string;
	author: string;
	authorUrl: string;
	demo: string;
	compatibleV0: string;
	compatibleV1: string;
	compatibleV2: string;
};

type MarkdownOutput = {
	frontmatter: PluginData;
	content: string;
};

type SidebarItem = {
	text: string;
	link: string;
	items?: SidebarItem[];
	collapsed?: boolean;
};

const pluginsDataPath = path.join(__dirname, '../hub/plugins');
const vitepressDirectoryPath = path.join(__dirname, '../hub/.vitepress');

const files = await readdir(pluginsDataPath, {withFileTypes: true, recursive: true});
const directories = files.filter(f => f.isDirectory());
const progressBar = createProgressBar();
createHeader('Processing plugins...');
progressBar.setTotal(directories.length);

const readNavigationData = async function (dirPath: string): Promise<NavigationData> {
	const pluginYamlPath = path.join(dirPath, '.navigation.yml');
	if (!(await pathExists(pluginYamlPath))) {
		throw new Error(`Navigation file not found: ${pluginYamlPath}`);
	}

	const yamlContent = await readFile(pluginYamlPath, 'utf-8');
	return parse(yamlContent);

};

const generateFileFrontmatter = function (): string {
	let content = '';
	content += '---\n';
	content += 'aside: false\n';
	content += '---\n\n';
	return content;
};

const generateAutoGeneratedNotice = function (): string {
	return '<!-- This file is auto-generated. Do not edit directly. -->\n\n';
};

const generateFileHeader = function (data: NavigationData, level: number, link?: string): string {
	let content = `${'#'.repeat(level)} `;
	const titleWithLink = link ? `[${data.title}](${link})` : data.title;
	content += `${titleWithLink}\n\n`;
	if (data.description) {
		content += `${data.description}\n\n`;
	}
	return content;
};

const getDirectories = async function (dirPath: string): Promise<string[]> {
	const entries = await readdir(dirPath, {withFileTypes: true});
	return entries.filter(e => e.isDirectory()).map(e => path.join(dirPath, e.name));
};

const extractMarkdownFrontmatter = function (frontmatter: string): PluginData {
	const parsedFrontmatter: PluginFrontmatter = parse(frontmatter);
	return {
		title: parsedFrontmatter.name,
		author: parsedFrontmatter.author.replaceAll(/\|/g, '\\|'),
		authorUrl: parsedFrontmatter['author-url'] || '',
		repo: parsedFrontmatter.repo,
		demo: parsedFrontmatter.demo,
		compatibleV0: parsedFrontmatter['compatible-v0'] ? '✅' : '',
		compatibleV1: parsedFrontmatter['compatible-v1'] ? '✅' : '',
		compatibleV2: parsedFrontmatter['compatible-v2'] ? '✅' : '',
	};
};

const processMarkdownFile = async function (filePath: string): Promise<MarkdownOutput> {
	const fileContent = await readFile(filePath, 'utf-8');
	const output: MarkdownOutput = {
		frontmatter: {} as PluginData,
		content: '',
	};

	const frontmatterMatch = fileContent.match(/^---\n([\s\S]+?)\n---/);
	if (!frontmatterMatch) {
		output.content = fileContent;
		return output;
	}

	const frontmatter = frontmatterMatch[1];
	output.frontmatter = extractMarkdownFrontmatter(frontmatter);

	const description = fileContent.slice(frontmatterMatch[0].length).trim();
	// replace new lines with spaces and escape pipe characters
	output.content = description.replace(/\n/g, ' ').replaceAll(/\|/g, '\\|');

	return output;
};

const generatePluginTable = async function (dirPath: string): Promise<string> {
	let tableContent = '| Plugin | Description | V1 | V2 | Demo | Maintainer |\n';
	tableContent += '|--------|-------------|----|----|------|------------|\n';
	const entries = await readdir(dirPath, {withFileTypes: true});
	const filteredEntries = entries.filter(entry => entry.isFile() && entry.name.endsWith('.md') && entry.name.toLowerCase() !== 'index.md');

	for (const entry of filteredEntries) {
		const pluginDir = path.join(dirPath, entry.name);
		const {frontmatter, content: description} = await processMarkdownFile(pluginDir);
		const {title, repo, author, authorUrl, demo, compatibleV1, compatibleV2} = frontmatter;
		const maintainer = authorUrl ? `[${author}](${authorUrl})` : author;
		const pluginTitle = repo ? `[${title}](${repo})` : title;
		const demoLink = demo ? `[Demo](${demo})` : '';
		tableContent += `| ${pluginTitle} | ${description} | ${compatibleV1} | ${compatibleV2} | ${demoLink} | ${maintainer} |\n`;
	}

	return `${tableContent  }\n`;
};

const writeIndexFile = async function (dirPath: string, content: string, fileName = 'index.md'): Promise<void> {
	const indexPath = path.join(dirPath, fileName);
	await writeFile(indexPath, content);
};

const createPluginIndexFile = async function (directoryPath: string, content: string): Promise<void> {
	let updatedContent = generateAutoGeneratedNotice();
	updatedContent += content;

	await writeIndexFile(directoryPath, updatedContent, 'plugins-index.md');
};

const generateMarkdownAndSidebar = async function (dirPath: string): Promise<SidebarItem[]> {
	const sidebar: SidebarItem[] = [];
	const topLevelDirs = await getDirectories(dirPath);

	let index = 0;
	let pluginIndexContent = '';
	for (const topDir of topLevelDirs) {
		const navigationData = await readNavigationData(topDir);
		let topLevelContent = generateFileFrontmatter();
		topLevelContent += generateAutoGeneratedNotice();
		topLevelContent += generateFileHeader(navigationData, 1);

		pluginIndexContent += generateFileHeader(navigationData, 2);

		const topLevelItem: SidebarItem = {
			text: navigationData.title,
			link: `/plugins/${path.basename(topDir)}/`,
			items: [],
			collapsed: index !== 0,
		};

		const subDirs = await getDirectories(topDir);
		for (const subDir of subDirs) {
			const subNavData = await readNavigationData(subDir);
			topLevelItem.items?.push({
				text: subNavData.title,
				link: `/plugins/${path.basename(topDir)}/${path.basename(subDir)}/`,
			});

			let subDirectoryContent = generateFileFrontmatter();
			subDirectoryContent += generateAutoGeneratedNotice();
			subDirectoryContent += generateFileHeader(subNavData, 1);
			subDirectoryContent += await generatePluginTable(subDir);

			topLevelContent += generateFileHeader(subNavData, 3, `./${path.basename(subDir)}/`);

			pluginIndexContent += generateFileHeader(subNavData, 3, `/plugins/${path.basename(topDir)}/${path.basename(subDir)}/`);

			await writeIndexFile(subDir, subDirectoryContent);
			progressBar.increment();
		}

		await writeIndexFile(topDir, topLevelContent);

		sidebar.push(topLevelItem);
		progressBar.increment();
		index++;
	}

	await createPluginIndexFile(dirPath, pluginIndexContent);
	progressBar.stop();
	console.log('Plugin markdown files and sidebar generated successfully.');
	return sidebar;
};

const sidebar = await generateMarkdownAndSidebar(pluginsDataPath);

// write
const sidebarPath = path.join(vitepressDirectoryPath, 'generated-sidebars', 'plugins-sidebar.ts');
await mkdir(path.dirname(sidebarPath), {recursive: true});
let sidebarContent = '// This file is auto-generated by scripts/generate-plugins.ts\n';
sidebarContent += `export default ${JSON.stringify(sidebar, null, '\t')};\n`;
await writeFile(sidebarPath, sidebarContent);

